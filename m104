#!/bin/sh 
set -f

alterator_api_version=1
. alterator-sh-functions


PROFILES_DIR="/home/test/m104"
CURRENT_PROFILE_FILE="$PROFILES_DIR/current_profile"


# Функция для получения текущего профиля
get_current_profile() {
    if [ -f "$CURRENT_PROFILE_FILE" ]; then
        # Читаем файл, убираем только переводы строк, но сохраняем пробелы
        current_profile=$(cat "$CURRENT_PROFILE_FILE" | tr -d '\n\r\t')
        # Если после очистки строка пустая, используем значение по умолчанию
        if [ -z "$current_profile" ]; then
            echo "m104"
        else
            echo "$current_profile"
        fi
    else
        echo "m104"  # профиль по умолчанию
    fi
}


# Функция для получения пути к конфигурационному файлу текущего профиля
get_config_file() {
    local profile=$(get_current_profile)
    echo "$PROFILES_DIR/$profile"
}


# Функция для установки профиля
set_profile() {
    local profile_name="$1"
    local config_file="$PROFILES_DIR/$profile_name"
    
    # Проверяем существование файла профиля
    if [ -f "$config_file" ]; then
        # Записываем в файл и сразу проверяем
        echo "$profile_name" > "$CURRENT_PROFILE_FILE"
        echo "DEBUG: Written to file: $profile_name" >&2
        echo "DEBUG: File content: $(cat $CURRENT_PROFILE_FILE)" >&2
        read_hosts_data >&3
    else
        echo "error: profile file $config_file not found" >&3
        # Если профиль не найден, возвращаемся к профилю по умолчанию
        echo "m104" > "$CURRENT_PROFILE_FILE"
        read_hosts_data >&3
    fi
}


# Функция для получения списка профилей
list_profiles() {
    find "$PROFILES_DIR" -maxdepth 1 -type f -not -name ".*" -exec basename {} \; | while read profile; do
        # Пропускаем файл текущего профиля
        if [ "$profile" != "current_profile" ]; then
            printf '(name "%s" description "%s")\n' "$profile" "$profile"
        fi
    done
}




update_status() {
    local process_num="$1"
    local new_status="$2"
    local config_file=$(get_config_file)
    
    # Создаем временный файл
    local temp_file=$(mktemp)
    
    # Обрабатываем файл и обновляем статус для нужного процесса
    awk -v proc="$process_num" -v newstat="$new_status" '
    BEGIN { in_target = 0 }
    /^process[[:space:]]*:[[:space:]]*/ {
        current_process = $NF
        if (current_process == proc) {
            in_target = 1
        } else {
            in_target = 0
        }
    }
    /^status[[:space:]]*:/ {
        if (in_target) {
            print "status\t: " newstat
            next
        }
    }
    { print }
    ' "$config_file" > "$temp_file"
    
    # Заменяем оригинальный файл
    mv "$temp_file" "$config_file"
}

update_status_start() {
    local process_num="$1"
    local new_status="$2"
    local config_file=$(get_config_file)
    
    # Создаем временный файл
    local temp_file=$(mktemp)
    
    # Обрабатываем файл и обновляем статус для нужного процесса
    awk -v proc="$process_num" -v newstat="$new_status" '
    BEGIN { in_target = 0 }
    /^process[[:space:]]*:[[:space:]]*/ {
        current_process = $NF
        if (current_process == proc) {
            in_target = 1
        } else {
            in_target = 0
        }
    }
    /^status[[:space:]]*:/ {
        if (in_target) {
            print "status\t: " newstat
            next
        }
    }
    { print }
    ' "$config_file" > "$temp_file"
    
    # Заменяем оригинальный файл
    mv "$temp_file" "$config_file"
}

update_status_stop() {
    local process_num="$1"
    local new_status="$2"
    local config_file=$(get_config_file)
    
    # Создаем временный файл
    local temp_file=$(mktemp)
    
    # Обрабатываем файл и обновляем статус для нужного процесса
    awk -v proc="$process_num" -v newstat="$new_status" '
    BEGIN { in_target = 0 }
    /^process[[:space:]]*:[[:space:]]*/ {
        current_process = $NF
        if (current_process == proc) {
            in_target = 1
        } else {
            in_target = 0
        }
    }
    /^status[[:space:]]*:/ {
        if (in_target) {
            print "status\t: " newstat
            next
        }
    }
    { print }
    ' "$config_file" > "$temp_file"
    
    # Заменяем оригинальный файл
    mv "$temp_file" "$config_file"
}

update_status_restart() {
    local process_num="$1"
    local new_status="$2"
    local config_file=$(get_config_file)
    
    # Создаем временный файл
    local temp_file=$(mktemp)
    
    # Обрабатываем файл и обновляем статус для нужного процесса
    awk -v proc="$process_num" -v newstat="$new_status" '
    BEGIN { in_target = 0 }
    /^process[[:space:]]*:[[:space:]]*/ {
        current_process = $NF
        if (current_process == proc) {
            in_target = 1
        } else {
            in_target = 0
        }
    }
    /^status[[:space:]]*:/ {
        if (in_target) {
            print "status\t: " newstat
            next
        }
    }
    { print }
    ' "$config_file" > "$temp_file"
    
    # Заменяем оригинальный файл
    mv "$temp_file" "$config_file"
}


# кнопка "Применить" для редактирования профиля

update_primary() {
    local process_num="$1"
    local new_primary="$2"
    local config_file=$(get_config_file)
    
    # Создаем временный файл
    local temp_file=$(mktemp)
    
    # Обрабатываем файл и обновляем primary для нужного процесса
    awk -v proc="$process_num" -v newprimary="$new_primary" '
    BEGIN { in_target = 0 }
    /^process[[:space:]]*:[[:space:]]*/ {
        current_process = $NF
        if (current_process == proc) {
            in_target = 1
        } else {
            in_target = 0
        }
    }
    /^primary[[:space:]]*:/ {
        if (in_target) {
            # Очищаем поле primary и записываем только новые данные
            print "primary\t: " newprimary
            next
        }
    }
    { print }
    ' "$config_file" > "$temp_file"
    
    # Заменяем оригинальный файл
    mv "$temp_file" "$config_file"
}

update_secondary() {
    local process_num="$1"
    local new_secondary="$2"
    local config_file=$(get_config_file)
    # Создаем временный файл
    local temp_file=$(mktemp)
    
    # Обрабатываем файл и обновляем primary для нужного процесса
    awk -v proc="$process_num" -v newsecondary="$new_secondary" '
    BEGIN { in_target = 0 }
    /^process[[:space:]]*:[[:space:]]*/ {
        current_process = $NF
        if (current_process == proc) {
            in_target = 1
        } else {
            in_target = 0
        }
    }
    /^secondary[[:space:]]*:/ {
        if (in_target) {
            # Очищаем поле secondary и записываем только новые данные
            print "secondary\t: " newsecondary
            next
        }
    }
    { print }
    ' "$config_file" > "$temp_file"
    
    # Заменяем оригинальный файл
    mv "$temp_file" "$config_file"
}


add_new_process() {
    local config_file=$(get_config_file)
    
    # Находим максимальный номер процесса
    local max_process=$(awk '/^process[[:space:]]*:/ {print $NF}' "$config_file" | sort -n | tail -1)
    local new_process=$((max_process + 1))
    
    # Добавляем новый процесс с ТАБОМ после названия поля (как в оригинале)
    cat >> "$config_file" << EOF

process	: $new_process
primary	: 0.0.0.0:0000
secondary	: Нет резерва
status	: ⚪ Остановлен
EOF
    
    echo "success" >&3
}
#\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ Удаление процесса \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
delete_process() {
    local config_file=$(get_config_file)
    local process_num="$1"
    
    local temp_file=$(mktemp)
    
    # Преобразуем process_num в массив (может содержать несколько процессов через разделитель)
    local IFS=';'
    local processes_to_delete=($process_num)
    unset IFS
    
    awk -v delete_procs="${processes_to_delete[*]}" '
    BEGIN {
        new_num = 0
        block = ""
        in_block = 0
        
        # Создаем массив процессов для удаления
        split(delete_procs, delete_arr, " ")
        for (i in delete_arr) {
            to_delete[delete_arr[i]] = 1
        }
    }
    
    # Заголовок профиля
    /^title[[:space:]]*:/ {
        print
        next
    }
    
    # Начало блока процесса
    /^process[[:space:]]*:[[:space:]]*/ {
        # Сохраняем предыдущий блок если он есть
        if (block != "") {
            if (!(current_proc in to_delete)) {
                new_num++
                print "process\t: " new_num
                printf "%s", block
            }
            block = ""
        }
        
        current_proc = $NF
        in_block = 1
        next
    }
    
    # Данные внутри блока процесса
    {
        if (in_block) {
            block = block $0 "\n"
        }
    }
    
    # Пустая строка - конец блока
    /^$/ {
        if (block != "") {
            if (!(current_proc in to_delete)) {
                new_num++
                print "process\t: " new_num
                printf "%s", block
            }
            block = ""
            print ""
        }
        in_block = 0
        next
    }
    
    END {
        # Последний блок
        if (block != "" && !(current_proc in to_delete)) {
            new_num++
            print "process\t: " new_num
            printf "%s", block
        }
    }' "$config_file" > "$temp_file"
    
    mv "$temp_file" "$config_file"
    echo "success" >&3
}





create_profile() {
    local profile_name="$1"
    local config_file="$PROFILES_DIR/$profile_name"
    
    # Проверяем, что имя профиля не пустое
    if [ -z "$profile_name" ]; then
        echo "error: profile name is empty" >&3
        return 1
    fi
    
    # Проверяем, что профиль еще не существует
    if [ -f "$config_file" ]; then
        echo "error: profile $profile_name already exists" >&3
        return 1
    fi
    
    # Создаем новый профиль с базовой структурой
    cat > "$config_file" << EOF
title	: Профиль $profile_name
process	: 1
primary	: 10.23.23.123:9595
secondary	: localhost:10232
status	: ⚫ Запущен
EOF
    
    # Немедленно устанавливаем созданный профиль как текущий
    echo "$profile_name" > "$CURRENT_PROFILE_FILE"
    
    echo "success" >&3
}

delete_current_profile() {
    local current_profile=$(get_current_profile)
    local config_file="$PROFILES_DIR/$current_profile"
    
    # Защита от удаления профиля по умолчанию
    if [ "$current_profile" = "m104" ]; then
        echo "error: cannot delete default profile m104" >&3
        return 1
    fi
    
    # Проверяем, что профиль существует
    if [ ! -f "$config_file" ]; then
        echo "error: current profile $current_profile does not exist" >&3
        return 1
    fi
    
    # Переключаемся на профиль по умолчанию
    echo "m104" > "$CURRENT_PROFILE_FILE"
    
    # Удаляем файл профиля
    rm -f "$config_file"
    
    echo "success" >&3
}


save_profile_as() {
    local new_profile_name="$1"
    local current_profile=$(get_current_profile)
    local current_config_file="$PROFILES_DIR/$current_profile"
    local new_config_file="$PROFILES_DIR/$new_profile_name"
    
    # Проверяем, что имя профиля не пустое
    if [ -z "$new_profile_name" ]; then
        echo "error: new profile name is empty" >&3
        return 1
    fi
    
    # Проверяем, что профиль еще не существует
    if [ -f "$new_config_file" ]; then
        echo "error: profile $new_profile_name already exists" >&3
        return 1
    fi
    
    # Проверяем, что текущий профиль существует
    if [ ! -f "$current_config_file" ]; then
        echo "error: current profile $current_profile does not exist" >&3
        return 1
    fi
    
    # Копируем содержимое текущего профиля в новый профиль
    cp "$current_config_file" "$new_config_file"
    
    # Обновляем заголовок в новом профиле
    sed -i "s/^title\t:.*/title\t: Профиль $new_profile_name/" "$new_config_file"
    
    # Устанавливаем новый профиль как текущий
    echo "$new_profile_name" > "$CURRENT_PROFILE_FILE"
    
    echo "success" >&3
}



# Функция для чтения данных хостов (обновленная)
read_hosts_data() {
    local config_file=$(get_config_file)
    local profile_title=$(awk -F '\t: ' '/^title/ {print $2; exit}' "$config_file")
    
    # Если title не найден, используем имя профиля как заголовок
    if [ -z "$profile_title" ]; then
        profile_title="Профиль $(get_current_profile)"
    fi
    
    awk -F '\t: ' -v title="$profile_title" '
    BEGIN{n=0;}
    function dump(){
        if (primary!=""){
            printf "(name \"%d\" process_num \"%d\" primary \"%s\" secondary \"%s\" status \"%s\" title \"%s\")\n",n,n,primary,secondary,status,title
        }
    }
    function clean(){
        primary=""; secondary=""; status="";
    }
    /^process/  {dump(); clean(); n=$2;}
    /^primary/  {primary=$2;}
    /^secondary/   {secondary=$2;}
    /^status/   {status=$2;}
    END{dump()}' < "$config_file"
}

on_message() {
    case "$in_action" in
        list)
            case "$in__objects" in
                profiles)
                    list_profiles >&3
                    ;;
                hosts)
                    read_hosts_data >&3
                    ;;
            esac
            ;;
        save_profile_as)
            if [ -n "$in_new_profile_name" ]; then
                save_profile_as "$in_new_profile_name"
                # Возвращаем обновленный список хостов
                read_hosts_data >&3
            fi
            ;;
        get_current_profile)
            get_current_profile >&3
            ;;
        set_profile)
            if [ -n "$in_profile_name" ]; then
                set_profile "$in_profile_name"
                # Возвращаем обновленный список хостов после смены профиля
                read_hosts_data >&3
            fi
            ;;
        create_profile)
            if [ -n "$in_profile_name" ]; then
                create_profile "$in_profile_name"
                echo "success" >&3
            fi
            ;;
        delete_current_profile)
                delete_current_profile
                echo "success" >&3
            ;;
        add_process)
            add_new_process
            read_hosts_data >&3
            ;;
        delete_process)
            if [ -n "$in_process_num" ]; then
                delete_process "$in_process_num"
                read_hosts_data >&3
            fi
            ;;    
        update_status|update_status_start|update_status_stop|update_status_restart)
            if [ -n "$in_process_num" ] && [ -n "$in_new_status" ]; then
                update_status "$in_process_num" "$in_new_status"
                echo "success" >&3
            fi
            ;;
        update_primary)
            if [ -n "$in_process_num" ] && [ -n "$in_new_primary" ]; then
                update_primary "$in_process_num" "$in_new_primary"
                echo "success" >&3
            fi
            ;;
        update_secondary)
            if [ -n "$in_process_num" ] && [ -n "$in_new_secondary" ]; then
                update_secondary "$in_process_num" "$in_new_secondary"
                echo "success" >&3
            fi
            ;;
    esac
}

message_loop